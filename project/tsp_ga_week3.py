import random
import numpy
import itertools 
import math

# 도시 개수
CITIES = 48
# population에 포함된 chromosome의 개수
SIZE = 200
# 세대
generation = 1


# 도시 간 거리
table = [[]]
# population
p = [[]]
# fitness
f = [0 for i in range(SIZE)]


def mix_initialize():
    p = []
    start = list(range(SIZE))
    
    random.shuffle(start)
        
    for i in range(SIZE):
        current = start[i]
        unvisited = list(range(SIZE))
        unvisited.remove(current)
        individual = [current]

        while unvisited:
            # 다음 도시 선택
            next_node = min(unvisited, key=lambda node: table[current][node])
            unvisited.remove(next_node)
            individual.append(next_node)
            current = next_node

        p.append(individual)
    
    return p

# 파일로부터 도시 간 거리 읽어와서 반환
def getTable(filename):
    f = open(filename, 'r')
    table = [[0 for col in range(CITIES)] for row in range(CITIES)]
    
    for i in range(CITIES):
        table[i] = list(map(float, f.readline().split()))

    return table
# ^getTable^

    
# 초기 population 반환 (order-based)
def getPopulation():
    p = [[col for col in range(CITIES)] for row in range(SIZE)]

    for i in range(SIZE):
        random.shuffle(p[i])
    
    return p
# ^getPopulation^


# chromosome의 fitness(도시 순회 시 총 거리) 반환
def getDistance(c):
    dist = 0
    
    for i in range(CITIES-1):
        dist += table[c[i]][c[i+1]]
    dist += table[c[CITIES-1]][c[0]]

    return dist
# ^getDistance^


# 가장 좋은 fitenss인(짧은 거리인) chromosome의 index 반환
def getBestIdx():
    minDist = numpy.finfo(numpy.float64).max
    idx = -1

    for i in range(SIZE):
        if(f[i] <= minDist):
            minDist = f[i]
            idx = i

    return idx
# ^getBestIdx^


# 가장 나쁜 fitness인(긴 거리인) chromosome의 index 반환
def getWorstIdx():
    maxDist = 0
    idx = -1

    for i in range(SIZE):
        if(f[i] >= maxDist):
            maxDist = f[i]
            idx = i

    return idx
# ^getWorstIdx^


#rouletteWheel
def rouletteWheel():
    #(Cw-Ci) + (Cw-Cb)/(k-1) , k = 3
    Cw = max(f)
    Cb = min(f)
    sum_fit = sum([(Cw-fit)+(Cw-Cb)/2 for fit in f])
    point = random.uniform(0,sum_fit)
    current_fit = 0 

    for i in range(SIZE):
        current_fit += (Cw-f[i])+(Cw-Cb)/2
        if point<=current_fit:
            return i
# ^rouletteWheel^

# tournamentSelection
def tournamentSelection(i1, i2):
    if(random.random() > 0.5):
        return i1 if f[i1] <= f[i2] else i2
    else:
        return i2 if f[i1] <= f[i2] else i1
# ^tournamentSelection^


# orderCrossOver
def orderCrossover(c1, c2, l, r):
    c = [0 for i in range(CITIES)]
    isVisited = [False for i in range(CITIES)]

    for i in range(l, r+1, 1):
        c[i] = c1[i]
        isVisited[c1[i]] = True

    for i in c2:
        if(isVisited[i] == False):
            r += 1
            c[r % CITIES] = i
    return c
# ^orderCrossover^


# cycleCrossover(chromosome1, chromosome2)
def cycleCrossover(c1, c2):
    # 반환할 offspring
    offspring = [-1 for i in range(CITIES)]
    
    # c1의 index 저장
    index = [-1 for i in range(CITIES)]
    for i in range(CITIES):
        index[c1[i]] = i

    # chromosome1에서 떼어올지 chromosome2에서 떼어올지 여부
    flag = True

    # cycle 되었는지 여부 저장
    isVisited = [False for i in range(CITIES)]

    for i in range(CITIES):
        if(offspring[i] == -1):
            temp = i
            
            while True:
                if(flag == True):
                    offspring[temp] = c1[temp] ### chromosome1
                else:
                    offspring[temp] = c2[temp] ### chromosome2
                    
                isVisited[temp] = True
                temp = index[c2[temp]]
                
                if(isVisited[temp] == True):
                    break
                
            flag = not flag
                
    return offspring
# ^cycleCrossover^


# pmx(chromosome1, chromosome2, index1, index2)
def pmx(c1, c2, i1, i2):
    # 반환할 offspring
    offspring = [-1 for i in range(CITIES)]
    
    # c1의 index 저장
    index = [-1 for i in range(CITIES)]
    for i in range(CITIES):
        index[c1[i]] = i

    # chromosome1의 부분을 떼어다가 그대로 붙여넣기
    isVisited = [False for i in range(CITIES)]
    for i in range(i1, i2+1):
        offspring[i] = c1[i]
        isVisited[c1[i]] = True

    # chromosome2 중복 처리
    for i in range(0, CITIES):
        if not i1 <= i <= i2:  # chromosome1에서 붙여넣은 부분이 아니라면
            temp = c2[i]
            while isVisited[temp]:  # 중복이 아니게 될 때까지
                temp = c2[index[temp]]
            offspring[i] = temp
                
    return offspring
# ^pmx^


# edgeRecombinationCrossover(chromosome1, chromosome2)
def edgeRecombinationCrossover(c1, c2):
    offspring = [-1 for i in range(CITIES)]

    table = [set() for i in range(CITIES)] ### 인접 도시 저장
    c1.append(c1[0])
    c2.append(c2[0])
    for i in range(CITIES):
        table[c1[i]].add(c1[i+1])
        table[c1[i+1]].add(c1[i])
        table[c2[i]].add(c2[i+1])
        table[c2[i+1]].add(c2[i])

    size = [0 for i in range(CITIES)] ### 각 도시의 이웃 개수 저장
    for i in range(CITIES):
        size[i] = len(table[i])
    
    isVisited = [False for i in range(CITIES)] ### 방문여부를 True, False로 저장
    unvisited_list = [i for i in range(CITIES)] ### 미방문여부를 list로 저장
    

    x = c1[0] if random.random() >= 0.5 else c2[0] ### 부모 중 랜덤하게 골라 맨 처음 노드 저장
    for i in range(CITIES):
        isVisited[x] = True
        unvisited_list.remove(x)
        offspring[i] = x

        # offspring이 완성되었으면
        if(i == CITIES-1):
            return offspring

        # 인접 도시 리스트에서 x 삭제
        for i in range(CITIES):
            if(isVisited[i] == False):
                if(x in table[i]):
                    table[i].discard(x)
                    size[i] -= 1

        # x의 이웃한 도시가 남아있지 않다면
        if(len(table[x]) == 0):
            # 방문하지 않은 도시들 중 랜덤으로 선택해 x에 저장
            x = random.choice(unvisited_list)
        # 아니라면
        else:
            # x의 이웃한 도시 중 가장 적은 인접 도시를 가진 도시를 뽑아 x에 저장 (2개 이상이라면 랜덤)
            neighbors = [[] for i in range(5)]
            for city in table[x]:
                neighbors[size[city]].append(city)
            for city in range(5):
                if(len(neighbors[city]) > 0):
                    x = random.choice(neighbors[city])
                    break
# ^edgeRecombinationCrossover^

def two_opt(c1):
    fit = getDistance(c1)
    c3 = c1.copy()
    for i in itertools.combinations((c1), 2):
        c2 = c1.copy()
        start, end = i[0], i[1]
        c2[start:end] = reversed(c1[start:end])
        if getDistance(c2) < fit:
            fit = getDistance(c2)
            c3 = c2.copy()
    return c3             

def three_opt(c):
    c3 = c
    dist = getDistance(c)

    for i, j, k in itertools.combinations(range(1, CITIES - 2), 3):
        new_c = c[:i] + c[i:j][::-1] + c[j:k][::-1] + c[k:]
        new_dist = getDistance(new_c)
        if new_dist < dist:
            dist = new_dist
            c3 = new_c

    return c3

def twohalf_opt(c):
    c1 = two_opt(c)
    c2 = three_opt(c)
    if(getDistance(c1) < getDistance(c)):
        return c1
    elif(getDistance(c2)< getDistance(c)):
        return c2
    else:
        return c
    
#################LK##################
def getCycle(c):
    city= []
    selected_city2 = 0  #출발 도시 
    selected_city1 = c[0][0]   #도착 도시
    city.append(selected_city1)
    while True:
        try:
            selected_city = [x for x in c[selected_city1] if x != selected_city2][0] # 출발 도시 할당 x 도착하고 다시 출발
            city.append(selected_city)
            selected_city2 = selected_city1
            selected_city1 = selected_city  
        except IndexError:
            break
        if selected_city == 0:
            return city

def LocuseGetDistance(c):
    dist = 0
    
    for i in range(CITIES):
        dist += table[i][c[i]]

    return dist
# order > locus
def locusEncoding(c):
    c1 = [0 for i in range(CITIES)]
    c2 = [0 for i in range(CITIES)]
    for i in range(CITIES):
        try:
            c1[c[i]] = c[i+1]
        except IndexError:
            c1[c[i]] = c[0]
    for i in range(CITIES):
        c2[c1[i]] = i       
    return c1 , c2 
# locus -> order
def orderEncoding(c):
    c1 = [0 for i in range(CITIES)]
    c1[0] = c[0]
    for i in range(1, CITIES):
        c1[i] = c[c1[i-1]]
    return c1

def LK(c):
    while True:
        c, reverse_dir_c = locusEncoding(c) 
        c1 = [[] for i in range(CITIES)] # 인접 도시 인코딩
        for i in range(CITIES):
            c1[i] = [c[i],reverse_dir_c[i]]
        
        lock_lst = [False for i in range(CITIES)]
        
        first = random.randint(0,CITIES-2)
        lock_lst[first] = True # 시작 노드 Lock     
        start = c1[first][0]   # 시작 노드의 인접노드에서 시작    
        c1[start].remove(first) # 인접노드 삭제
        c1[first].remove(start) # 인접노드 삭제
        while True:
            edge_fit = [table[start][i] for i in range(CITIES)] # 시작 도시에서 모든 도시 거리 
            best = 100000
            end = -1
            for i in range(CITIES):# 가장 가까운 도시구하기
                if lock_lst[i]==False and i not in c1[start]: #Lock  되지 않고 시작노드의 인접노드가 아님 
                    if 0<edge_fit[i]<best:
                        best = edge_fit[i]
                        end = i
            if end == -1:#start의 인접노드만 Lock 되지 않음 
                c1[first].append(start)
                c1[start].append(first)
                c1 = getCycle(c1)
                c_fit = LocuseGetDistance(c) 
                c1_fit = LocuseGetDistance(c1) 
                if c_fit<=c1_fit:  # 더 좋은 염색체 선택
                    orderEncoding(c)
                    return c
                else:
                    c = c1
                    break
            c1[start].append(end)  #시작 도시의 인접노드에 도착도시 추가 
            c1[end].append(start)  
            lock_lst[end]=True     #도착 도시 Lock 
            F = True
            for i in c1[end]:  #추가한 도시와 인접도시들을 순회 / 싸이클 삭제하는것임 
                if i == start: #출발 도시는 빼야됨  
                    pass
                selected_city2 = end  #출발 도시 
                selected_city1 = i    #도착 도시 
                while F:
                    try:
                        selected_city = [x for x in c1[selected_city1] if x != selected_city2][0] # 출발 도시 할당 x 도착하고 다시 출발  
                        selected_city2 = selected_city1
                        selected_city1 = selected_city  
                    except IndexError:
                        break
                    if selected_city == end: # 사이클이라면 삭제 
                        F = False
                        c1[i].remove(end)
                        c1[end].remove(i)
                        start = i
                        break

            if all(lock_lst):
                c1[first].append(start)
                c1[start].append(first)
                c1 = getCycle(c1) # orderbase 
                c_fit = LocuseGetDistance(c) #locus
                c1_fit = getDistance(c1) # order 
                if c_fit<=c1_fit:  # 더 좋은 염색체 선택
                    c = orderEncoding(c)
                    return c
                else:
                    c = c1
                    break
##########################LK############################

def mutate(individual):
    mutation_rate = 0.05
    if random.random() < mutation_rate:
        i, j = random.sample(range(len(individual)), 2)
        individual[i], individual[j] = individual[j], individual[i]

def inversion_mutation(individual, mutation_rate):
    # 뮤테이션 확률을 체크
    if random.random() < mutation_rate:
        # 랜덤하게 두 위치 선택
        index1, index2 = random.sample(range(len(individual)), 2)
        index1, index2 = min(index1, index2), max(index1, index2)

        # 선택한 범위 내의 유전자를 역전시킴
        individual[index1:index2+1] = reversed(individual[index1:index2+1])

    return individual    

# 이하 main
table = table = [[0.0, 4727.0, 1205.0, 6363.0, 3657.0, 3130.0, 2414.0, 563.0, 463.0, 5654.0, 1713.0, 1604.0, 2368.0, 2201.0, 1290.0, 1004.0, 3833.0, 2258.0, 3419.0, 2267.0, 2957.0, 720.0, 1700.0, 5279.0, 2578.0, 6076.0, 3465.0, 2654.0, 3625.0, 3115.0, 1574.0, 3951.0, 1748.0, 2142.0, 6755.0, 2383.0, 3306.0, 1029.0, 3530.0, 825.0, 2188.0, 4820.0, 3489.0, 1947.0, 6835.0, 1542.0, 2379.0, 3744.0], [4727.0, 0.0, 3588.0, 2012.0, 1842.0, 6977.0, 6501.0, 5187.0, 5028.0, 2327.0, 4148.0, 4723.0, 3635.0, 3125.0, 4907.0, 3930.0, 7463.0, 6338.0, 7243.0, 5105.0, 4043.0, 4022.0, 3677.0, 2863.0, 3106.0, 1850.0, 7173.0, 6630.0, 1204.0, 6814.0, 6001.0, 3447.0, 5253.0, 2656.0, 3123.0, 6274.0, 7183.0, 5622.0, 3085.0, 4564.0, 2756.0, 1591.0, 7027.0, 6186.0, 3472.0, 5461.0, 4390.0, 2088.0], [1205.0, 3588.0, 0.0, 5163.0, 2458.0, 3678.0, 3071.0, 1742.0, 1444.0, 4462.0, 1184.0, 1520.0, 1498.0, 1103.0, 1501.0, 951.0, 4298.0, 2903.0, 3967.0, 2169.0, 2209.0, 652.0, 828.0, 4136.0, 1518.0, 4873.0, 3954.0, 3254.0, 2446.0, 3581.0, 2441.0, 2960.0, 1966.0, 950.0, 5564.0, 2916.0, 3878.0, 2035.0, 2482.0, 1027.0, 1395.0, 3617.0, 3891.0, 2686.0, 5661.0, 2023.0, 1867.0, 2560.0], [6363.0, 2012.0, 5163.0, 0.0, 2799.0, 8064.0, 7727.0, 6878.0, 6581.0, 1402.0, 5366.0, 5946.0, 4679.0, 4378.0, 6225.0, 5709.0, 8417.0, 7578.0, 8296.0, 6135.0, 4802.0, 5707.0, 4982.0, 2322.0, 4178.0, 320.0, 8186.0, 7800.0, 2778.0, 7859.0, 7408.0, 3763.0, 6461.0, 4223.0, 1427.0, 7451.0, 8263.0, 7131.0, 3669.0, 6011.0, 4638.0, 1681.0, 7987.0, 7502.0, 1877.0, 6758.0, 5360.0, 2844.0], [3657.0, 1842.0, 2458.0, 2799.0, 0.0, 5330.0, 4946.0, 4200.0, 3824.0, 2012.0, 2573.0, 3157.0, 1924.0, 1580.0, 3427.0, 3179.0, 5749.0, 4793.0, 5577.0, 3409.0, 2223.0, 3066.0, 2185.0, 1860.0, 1401.0, 2491.0, 5486.0, 5035.0, 894.0, 5141.0, 4611.0, 1669.0, 3677.0, 1590.0, 3113.0, 4682.0, 5533.0, 4352.0, 1252.0, 3227.0, 2426.0, 1169.0, 5313.0, 4706.0, 3241.0, 3962.0, 2651.0, 304.0], [3130.0, 6977.0, 3678.0, 8064.0, 5330.0, 0.0, 743.0, 3209.0, 2670.0, 6929.0, 2831.0, 2266.0, 3407.0, 3854.0, 2178.0, 4076.0, 727.0, 881.0, 293.0, 1930.0, 3310.0, 3672.0, 3315.0, 6199.0, 3932.0, 7745.0, 365.0, 482.0, 5774.0, 261.0, 1659.0, 4513.0, 1746.0, 4431.0, 7910.0, 769.0, 207.0, 2225.0, 4435.0, 2681.0, 5053.0, 6384.0, 550.0, 1224.0, 7805.0, 1670.0, 2704.0, 5230.0], [2414.0, 6501.0, 3071.0, 7727.0, 4946.0, 743.0, 0.0, 2468.0, 1952.0, 6673.0, 2380.0, 1795.0, 3051.0, 3405.0, 1604.0, 3382.0, 1469.0, 168.0, 1020.0, 1681.0, 3110.0, 2993.0, 2827.0, 6009.0, 3552.0, 7412.0, 1104.0, 267.0, 5300.0, 821.0, 916.0, 4348.0, 1270.0, 3890.0, 7698.0, 332.0, 900.0, 1484.0, 4185.0, 2049.0, 4415.0, 6051.0, 1219.0, 482.0, 7635.0, 1054.0, 2432.0, 4884.0], [563.0, 5187.0, 1742.0, 6878.0, 4200.0, 3209.0, 2468.0, 0.0, 718.0, 6203.0, 2241.0, 2051.0, 2920.0, 2762.0, 1687.0, 1304.0, 3932.0, 2331.0, 3487.0, 2669.0, 3487.0, 1175.0, 2260.0, 5840.0, 3141.0, 6596.0, 3563.0, 2728.0, 4120.0, 3240.0, 1559.0, 4507.0, 2082.0, 2658.0, 7304.0, 2512.0, 3364.0, 985.0, 4091.0, 1319.0, 2544.0, 5358.0, 3632.0, 1987.0, 7391.0, 1785.0, 2879.0, 4296.0], [463.0, 5028.0, 1444.0, 6581.0, 3824.0, 2670.0, 1952.0, 718.0, 0.0, 5789.0, 1602.0, 1343.0, 2330.0, 2291.0, 970.0, 1451.0, 3376.0, 1796.0, 2959.0, 1951.0, 2835.0, 1112.0, 1725.0, 5346.0, 2628.0, 6285.0, 3007.0, 2193.0, 3889.0, 2661.0, 1122.0, 3920.0, 1372.0, 2391.0, 6883.0, 1927.0, 2845.0, 611.0, 3543.0, 676.0, 2590.0, 4993.0, 3039.0, 1486.0, 6934.0, 1112.0, 2196.0, 3876.0], [5654.0, 2327.0, 4462.0, 1402.0, 2012.0, 6929.0, 6673.0, 6203.0, 5789.0, 0.0, 4392.0, 4947.0, 3648.0, 3501.0, 5274.0, 5183.0, 7216.0, 6535.0, 7140.0, 5022.0, 3621.0, 5077.0, 4090.0, 922.0, 3207.0, 1131.0, 7014.0, 6714.0, 2437.0, 6707.0, 6477.0, 2476.0, 5432.0, 3599.0, 1102.0, 6376.0, 7121.0, 6284.0, 2497.0, 5160.0, 4318.0, 937.0, 6795.0, 6507.0, 1268.0, 5773.0, 4249.0, 1914.0], [1713.0, 4148.0, 1184.0, 5366.0, 2573.0, 2831.0, 2380.0, 2241.0, 1602.0, 4392.0, 0.0, 586.0, 766.0, 1029.0, 883.0, 2040.0, 3353.0, 2224.0, 3100.0, 1049.0, 1246.0, 1625.0, 503.0, 3841.0, 1196.0, 5054.0, 3042.0, 2488.0, 2945.0, 2676.0, 2087.0, 2331.0, 1114.0, 1650.0, 5459.0, 2132.0, 3037.0, 1958.0, 1997.0, 931.0, 2513.0, 3701.0, 2923.0, 2137.0, 5459.0, 1394.0, 711.0, 2534.0], [1604.0, 4723.0, 1520.0, 5946.0, 3157.0, 2266.0, 1795.0, 2051.0, 1343.0, 4947.0, 586.0, 0.0, 1299.0, 1612.0, 406.0, 2208.0, 2824.0, 1639.0, 2542.0, 694.0, 1586.0, 1767.0, 1050.0, 4357.0, 1770.0, 5633.0, 2498.0, 1907.0, 3520.0, 2128.0, 1558.0, 2778.0, 531.0, 2171.0, 6003.0, 1552.0, 2472.0, 1538.0, 2506.0, 791.0, 2912.0, 4277.0, 2403.0, 1564.0, 5983.0, 827.0, 892.0, 3109.0], [2368.0, 3635.0, 1498.0, 4679.0, 1924.0, 3407.0, 3051.0, 2920.0, 2330.0, 3648.0, 766.0, 1299.0, 0.0, 646.0, 1642.0, 2446.0, 3840.0, 2905.0, 3655.0, 1488.0, 730.0, 2096.0, 697.0, 3076.0, 533.0, 4363.0, 3567.0, 3122.0, 2453.0, 3219.0, 2842.0, 1592.0, 1791.0, 1480.0, 4706.0, 2772.0, 3610.0, 2721.0, 1232.0, 1656.0, 2550.0, 3001.0, 3403.0, 2860.0, 4697.0, 2126.0, 756.0, 1836.0], [2201.0, 3125.0, 1103.0, 4378.0, 1580.0, 3854.0, 3405.0, 2762.0, 2291.0, 3501.0, 1029.0, 1612.0, 646.0, 0.0, 1853.0, 2026.0, 4349.0, 3247.0, 4119.0, 1997.0, 1341.0, 1753.0, 606.0, 3078.0, 419.0, 4070.0, 4052.0, 3517.0, 1923.0, 3690.0, 3032.0, 1866.0, 2142.0, 838.0, 4593.0, 3161.0, 4060.0, 2788.0, 1380.0, 1663.0, 1932.0, 2736.0, 3915.0, 3138.0, 4647.0, 2395.0, 1351.0, 1592.0], [1290.0, 4907.0, 1501.0, 6225.0, 3427.0, 2178.0, 1604.0, 1687.0, 970.0, 5274.0, 883.0, 406.0, 1642.0, 1853.0, 0.0, 2029.0, 2803.0, 1438.0, 2466.0, 986.0, 1987.0, 1593.0, 1253.0, 4716.0, 2072.0, 5915.0, 2454.0, 1764.0, 3710.0, 2082.0, 1204.0, 3164.0, 497.0, 2287.0, 6342.0, 1419.0, 2379.0, 1134.0, 2867.0, 554.0, 2885.0, 4569.0, 2405.0, 1289.0, 6338.0, 555.0, 1297.0, 3406.0], [1004.0, 3930.0, 951.0, 5709.0, 3179.0, 4076.0, 3382.0, 1304.0, 1451.0, 5183.0, 2040.0, 2208.0, 2446.0, 2026.0, 2029.0, 0.0, 4759.0, 3220.0, 4368.0, 2900.0, 3151.0, 442.0, 1765.0, 4960.0, 2444.0, 5443.0, 4396.0, 3610.0, 2932.0, 4034.0, 2572.0, 3891.0, 2525.0, 1590.0, 6278.0, 3313.0, 4261.0, 2033.0, 3398.0, 1476.0, 1241.0, 4287.0, 4390.0, 2928.0, 6419.0, 2428.0, 2749.0, 3337.0], [3833.0, 7463.0, 4298.0, 8417.0, 5749.0, 727.0, 1469.0, 3932.0, 3376.0, 7216.0, 3353.0, 2824.0, 3840.0, 4349.0, 2803.0, 4759.0, 0.0, 1601.0, 477.0, 2359.0, 3617.0, 4345.0, 3851.0, 6433.0, 4372.0, 8098.0, 370.0, 1206.0, 6267.0, 726.0, 2384.0, 4754.0, 2335.0, 4991.0, 8148.0, 1452.0, 609.0, 2949.0, 4752.0, 3331.0, 5687.0, 6746.0, 437.0, 1948.0, 8005.0, 2334.0, 3098.0, 5618.0], [2258.0, 6338.0, 2903.0, 7578.0, 4793.0, 881.0, 168.0, 2331.0, 1796.0, 6535.0, 2224.0, 1639.0, 2905.0, 3247.0, 1438.0, 3220.0, 1601.0, 0.0, 1165.0, 1563.0, 2988.0, 2829.0, 2666.0, 5882.0, 3401.0, 7263.0, 1233.0, 399.0, 5138.0, 923.0, 794.0, 4227.0, 1117.0, 3724.0, 7565.0, 286.0, 1049.0, 1348.0, 4051.0, 1881.0, 4248.0, 5903.0, 1322.0, 355.0, 7508.0, 887.0, 2302.0, 4736.0], [3419.0, 7243.0, 3967.0, 8296.0, 5577.0, 293.0, 1020.0, 3487.0, 2959.0, 7140.0, 3100.0, 2542.0, 3655.0, 4119.0, 2466.0, 4368.0, 477.0, 1165.0, 0.0, 2170.0, 3520.0, 3965.0, 3588.0, 6393.0, 4183.0, 7977.0, 202.0, 767.0, 6041.0, 438.0, 1932.0, 4706.0, 2027.0, 4711.0, 8107.0, 1061.0, 132.0, 2503.0, 4652.0, 2972.0, 5344.0, 6617.0, 486.0, 1501.0, 7989.0, 1962.0, 2939.0, 5469.0], [2267.0, 5105.0, 2169.0, 6135.0, 3409.0, 1930.0, 1681.0, 2669.0, 1951.0, 5022.0, 1049.0, 694.0, 1488.0, 1997.0, 986.0, 2900.0, 2359.0, 1563.0, 2170.0, 0.0, 1430.0, 2460.0, 1547.0, 4333.0, 2019.0, 5817.0, 2079.0, 1694.0, 3910.0, 1733.0, 1813.0, 2668.0, 654.0, 2694.0, 6029.0, 1366.0, 2130.0, 1991.0, 2525.0, 1474.0, 3542.0, 4455.0, 1923.0, 1641.0, 5957.0, 1071.0, 777.0, 3302.0], [2957.0, 4043.0, 2209.0, 4802.0, 2223.0, 3310.0, 3110.0, 3487.0, 2835.0, 3621.0, 1246.0, 1586.0, 730.0, 1341.0, 1987.0, 3151.0, 3617.0, 2988.0, 3520.0, 1430.0, 0.0, 2779.0, 1387.0, 2905.0, 1062.0, 4482.0, 3398.0, 3119.0, 2922.0, 3087.0, 3115.0, 1240.0, 1953.0, 2175.0, 4607.0, 2796.0, 3501.0, 3119.0, 1136.0, 2173.0, 3268.0, 3136.0, 3189.0, 3029.0, 4527.0, 2355.0, 711.0, 2042.0], [720.0, 4022.0, 652.0, 5707.0, 3066.0, 3672.0, 2993.0, 1175.0, 1112.0, 5077.0, 1625.0, 1767.0, 2096.0, 1753.0, 1593.0, 442.0, 4345.0, 2829.0, 3965.0, 2460.0, 2779.0, 0.0, 1401.0, 4781.0, 2166.0, 5427.0, 3984.0, 3212.0, 2946.0, 3620.0, 2224.0, 3603.0, 2089.0, 1496.0, 6178.0, 2906.0, 3861.0, 1719.0, 3132.0, 1040.0, 1479.0, 4211.0, 3969.0, 2553.0, 6290.0, 2012.0, 2336.0, 3189.0], [1700.0, 3677.0, 828.0, 4982.0, 2185.0, 3315.0, 2827.0, 2260.0, 1725.0, 4090.0, 503.0, 1050.0, 697.0, 606.0, 1253.0, 1765.0, 3851.0, 2666.0, 3588.0, 1547.0, 1387.0, 1401.0, 0.0, 3621.0, 903.0, 4675.0, 3537.0, 2954.0, 2475.0, 3169.0, 2427.0, 2254.0, 1578.0, 1148.0, 5177.0, 2598.0, 3521.0, 2194.0, 1833.0, 1074.0, 2054.0, 3340.0, 3423.0, 2541.0, 5213.0, 1801.0, 1077.0, 2190.0], [5279.0, 2863.0, 4136.0, 2322.0, 1860.0, 6199.0, 6009.0, 5840.0, 5346.0, 922.0, 3841.0, 4357.0, 3076.0, 3078.0, 4716.0, 4960.0, 6433.0, 5882.0, 6393.0, 4333.0, 2905.0, 4781.0, 3621.0, 0.0, 2718.0, 2042.0, 6254.0, 6024.0, 2569.0, 5966.0, 5913.0, 1687.0, 4807.0, 3384.0, 1716.0, 5699.0, 6384.0, 5787.0, 1852.0, 4687.0, 4285.0, 1272.0, 6022.0, 5892.0, 1629.0, 5178.0, 3581.0, 1639.0],[2578.0, 3106.0, 1518.0, 4178.0, 1401.0, 3932.0, 3552.0, 3141.0, 2628.0, 3207.0, 1196.0, 1770.0, 533.0, 419.0, 2072.0, 2444.0, 4372.0, 3401.0, 4183.0, 2019.0, 1062.0, 2166.0, 903.0, 2718.0, 0.0, 3864.0, 4097.0, 3635.0, 1932.0, 3748.0, 3274.0, 1448.0, 2284.0, 1164.0, 4286.0, 3283.0, 4136.0, 3086.0, 967.0, 1973.0, 2285.0, 2507.0, 3935.0, 3331.0, 4312.0, 2589.0, 1284.0, 1340.0], [6076.0, 1850.0, 4873.0, 320.0, 2491.0, 7745.0, 7412.0, 6596.0, 6285.0, 1131.0, 5054.0, 5633.0, 4363.0, 4070.0, 5915.0, 5443.0, 8098.0, 7263.0, 7977.0, 5817.0, 4482.0, 5427.0, 4675.0, 2042.0, 3864.0, 0.0, 7866.0, 7483.0, 2515.0, 7539.0, 7101.0, 3449.0, 6146.0, 3938.0, 1375.0, 7134.0, 7944.0, 6831.0, 3349.0, 5709.0, 4397.0, 1363.0, 7667.0, 7190.0, 1798.0, 6446.0, 5041.0, 2528.0], [3465.0, 7173.0, 3954.0, 8186.0, 5486.0, 365.0, 1104.0, 3563.0, 3007.0, 7014.0, 3042.0, 2498.0, 3567.0, 4052.0, 2454.0, 4396.0, 370.0, 1233.0, 202.0, 2079.0, 3398.0, 3984.0, 3537.0, 6254.0, 4097.0, 7866.0, 0.0, 839.0, 5973.0, 374.0, 2019.0, 4569.0, 1996.0, 4669.0, 7970.0, 1085.0, 305.0, 2581.0, 4532.0, 2976.0, 5339.0, 6509.0, 287.0, 1581.0, 7844.0, 1974.0, 2838.0, 5369.0], [2654.0, 6630.0, 3254.0, 7800.0, 5035.0, 482.0, 267.0, 2728.0, 2193.0, 6714.0, 2488.0, 1907.0, 3122.0, 3517.0, 1764.0, 3610.0, 1206.0, 399.0, 767.0, 1694.0, 3119.0, 3212.0, 2954.0, 6024.0, 3635.0, 7483.0, 839.0, 0.0, 5427.0, 558.0, 1181.0, 4349.0, 1377.0, 4044.0, 7723.0, 356.0, 653.0, 1744.0, 4218.0, 2241.0, 4614.0, 6121.0, 955.0, 743.0, 7644.0, 1231.0, 2465.0, 4957.0], [3625.0, 1204.0, 2446.0, 2778.0, 894.0, 5774.0, 5300.0, 4120.0, 3889.0, 2437.0, 2945.0, 3520.0, 2453.0, 1923.0, 3710.0, 2932.0, 6267.0, 5138.0, 6041.0, 3910.0, 2922.0, 2946.0, 2475.0, 2569.0, 1932.0, 2515.0, 5973.0, 5427.0, 0.0, 5612.0, 4824.0, 2550.0, 4050.0, 1498.0, 3476.0, 5071.0, 5980.0, 4470.0, 2096.0, 3388.0, 1911.0, 1501.0, 5831.0, 4994.0, 3704.0, 4264.0, 3209.0, 1196.0], [3115.0, 6814.0, 3581.0, 7859.0, 5141.0, 261.0, 821.0, 3240.0, 2661.0, 6707.0, 2676.0, 2128.0, 3219.0, 3690.0, 2082.0, 4034.0, 726.0, 923.0, 438.0, 1733.0, 3087.0, 3620.0, 3169.0, 5966.0, 3748.0, 7539.0, 374.0, 558.0, 5612.0, 0.0, 1716.0, 4280.0, 1624.0, 4298.0, 7679.0, 735.0, 420.0, 2263.0, 4216.0, 2606.0, 4967.0, 6179.0, 400.0, 1277.0, 7567.0, 1609.0, 2501.0, 5032.0], [1574.0, 6001.0, 2441.0, 7408.0, 4611.0, 1659.0, 916.0, 1559.0, 1122.0, 6477.0, 2087.0, 1558.0, 2842.0, 3032.0, 1204.0, 2572.0, 2384.0, 794.0, 1932.0, 1813.0, 3115.0, 2224.0, 2427.0, 5913.0, 3274.0, 7101.0, 2019.0, 1181.0, 4824.0, 1716.0, 0.0, 4330.0, 1180.0, 3346.0, 7545.0, 1023.0, 1808.0, 578.0, 4062.0, 1438.0, 3693.0, 5763.0, 2115.0, 440.0, 7537.0, 763.0, 2404.0, 4603.0], [3951.0, 3447.0, 2960.0, 3763.0, 1669.0, 4513.0, 4348.0, 4507.0, 3920.0, 2476.0, 2331.0, 2778.0, 1592.0, 1866.0, 3164.0, 3891.0, 4754.0, 4227.0, 4706.0, 2668.0, 1240.0, 3603.0, 2254.0, 1687.0, 1448.0, 3449.0, 4569.0, 4349.0, 2550.0, 4280.0, 4330.0, 0.0, 3184.0, 2510.0, 3402.0, 4031.0, 4698.0, 4281.0, 533.0, 3245.0, 3612.0, 2187.0, 4339.0, 4265.0, 3296.0, 3576.0, 1941.0, 1381.0], [1748.0, 5253.0, 1966.0, 6461.0, 3677.0, 1746.0, 1270.0, 2082.0, 1372.0, 5432.0, 1114.0, 531.0, 1791.0, 2142.0, 497.0, 2525.0, 2335.0, 1117.0, 2027.0, 654.0, 1953.0, 2089.0, 1578.0, 4807.0, 2284.0, 6146.0, 1996.0, 1377.0, 4050.0, 1624.0, 1180.0, 3184.0, 0.0, 2685.0, 6475.0, 1022.0, 1952.0, 1341.0, 2963.0, 1050.0, 3358.0, 4787.0, 1926.0, 1086.0, 6436.0, 422.0, 1244.0, 3619.0], [2142.0, 2656.0, 950.0, 4223.0, 1590.0, 4431.0, 3890.0, 2658.0, 2391.0, 3599.0, 1650.0, 2171.0, 1480.0, 838.0, 2287.0, 1590.0, 4991.0, 3724.0, 4711.0, 2694.0, 2175.0, 1496.0, 1148.0, 3384.0, 1164.0, 3938.0, 4669.0, 4044.0, 1498.0, 4298.0, 3346.0, 2510.0, 2685.0, 0.0, 4697.0, 3693.0, 4636.0, 2975.0, 1981.0, 1909.0, 1124.0, 2718.0, 4565.0, 3548.0, 4830.0, 2839.0, 2140.0, 1751.0], [6755.0, 3123.0, 5564.0, 1427.0, 3113.0, 7910.0, 7698.0, 7304.0, 6883.0, 1102.0, 5459.0, 6003.0, 4706.0, 4593.0, 6342.0, 6278.0, 8148.0, 7565.0, 8107.0, 6029.0, 4607.0, 6178.0, 5177.0, 1716.0, 4286.0, 1375.0, 7970.0, 7723.0, 3476.0, 7679.0, 7545.0, 3402.0, 6475.0, 4697.0, 0.0, 7393.0, 8097.0, 7370.0, 3515.0, 6249.0, 5379.0, 2001.0, 7738.0, 7556.0, 461.0, 6829.0, 5267.0, 3013.0], [2383.0, 6274.0, 2916.0, 7451.0, 4682.0, 769.0, 332.0, 2512.0, 1927.0, 6376.0, 2132.0, 1552.0, 2772.0, 3161.0, 1419.0, 3313.0, 1452.0, 286.0, 1061.0, 1366.0, 2796.0, 2906.0, 2598.0, 5699.0, 3283.0, 7134.0, 1085.0, 356.0, 5071.0, 735.0, 1023.0, 4031.0, 1022.0, 3693.0, 7393.0, 0.0, 965.0, 1542.0, 3883.0, 1913.0, 4286.0, 5772.0, 1121.0, 600.0, 7322.0, 902.0, 2128.0, 4608.0], [3306.0, 7183.0, 3878.0, 8263.0, 5533.0, 207.0, 900.0, 3364.0, 2845.0, 7121.0, 3037.0, 2472.0, 3610.0, 4060.0, 2379.0, 4261.0, 609.0, 1049.0, 132.0, 2130.0, 3501.0, 3861.0, 3521.0, 6384.0, 4136.0, 7944.0, 305.0, 653.0, 5980.0, 420.0, 1808.0, 4698.0, 1952.0, 4636.0, 8097.0, 965.0, 0.0, 2380.0, 4629.0, 2877.0, 5250.0, 6583.0, 570.0, 1380.0, 7986.0, 1866.0, 2904.0, 5432.0], [1029.0, 5622.0, 2035.0, 7131.0, 4352.0, 2225.0, 1484.0, 985.0, 611.0, 6284.0, 1958.0, 1538.0, 2721.0, 2788.0, 1134.0, 2033.0, 2949.0, 1348.0, 2503.0, 1991.0, 3119.0, 1719.0, 2194.0, 5787.0, 3086.0, 6831.0, 2581.0, 1744.0, 4470.0, 2263.0, 578.0, 4281.0, 1341.0, 2975.0, 7370.0, 1542.0, 2380.0, 0.0, 3952.0, 1127.0, 3197.0, 5518.0, 2658.0, 1002.0, 7395.0, 951.0, 2429.0, 4380.0], [3530.0, 3085.0, 2482.0, 3669.0, 1252.0, 4435.0, 4185.0, 4091.0, 3543.0, 2497.0, 1997.0, 2506.0, 1232.0, 1380.0, 2867.0, 3398.0, 4752.0, 4051.0, 4652.0, 2525.0, 1136.0, 3132.0, 1833.0, 1852.0, 967.0, 3349.0, 4532.0, 4218.0, 2096.0, 4216.0, 4062.0, 533.0, 2963.0, 1981.0, 3515.0, 3883.0, 4629.0, 3952.0, 0.0, 2873.0, 3080.0, 2012.0, 4324.0, 4046.0, 3478.0, 3328.0, 1755.0, 1000.0], [825.0, 4564.0, 1027.0, 6011.0, 3227.0, 2681.0, 2049.0, 1319.0, 676.0, 5160.0, 931.0, 791.0, 1656.0, 1663.0, 554.0, 1476.0, 3331.0, 1881.0, 2972.0, 1474.0, 2173.0, 1040.0, 1074.0, 4687.0, 1973.0, 5709.0, 2976.0, 2241.0, 3388.0, 2606.0, 1438.0, 3245.0, 1050.0, 1909.0, 6249.0, 1913.0, 2877.0, 1127.0, 2873.0, 0.0, 2374.0, 4392.0, 2943.0, 1659.0, 6285.0, 1012.0, 1563.0, 3254.0], [2188.0, 2756.0, 1395.0, 4638.0, 2426.0, 5053.0, 4415.0, 2544.0, 2590.0, 4318.0, 2513.0, 2912.0, 2550.0, 1932.0, 2885.0, 1241.0, 5687.0, 4248.0, 5344.0, 3542.0, 3268.0, 1479.0, 2054.0, 4285.0, 2285.0, 4397.0, 5339.0, 4614.0, 1911.0, 4967.0, 3693.0, 3612.0, 3358.0, 1124.0, 5379.0, 4286.0, 5250.0, 3197.0, 3080.0, 2374.0, 0.0, 3386.0, 5284.0, 3997.0, 5585.0, 3386.0, 3125.0, 2664.0], [4820.0, 1591.0, 3617.0, 1681.0, 1169.0, 6384.0, 6051.0, 5358.0, 4993.0, 937.0, 3701.0, 4277.0, 3001.0, 2736.0, 4569.0, 4287.0, 6746.0, 5903.0, 6617.0, 4455.0, 3136.0, 4211.0, 3340.0, 1272.0, 2507.0, 1363.0, 6509.0, 6121.0, 1501.0, 6179.0, 5763.0, 2187.0, 4787.0, 2718.0, 2001.0, 5772.0, 6583.0, 5518.0, 2012.0, 4392.0, 3386.0, 0.0, 6314.0, 5837.0, 2205.0, 5095.0, 3680.0, 1169.0], [3489.0, 7027.0, 3891.0, 7987.0, 5313.0, 550.0, 1219.0, 3632.0, 3039.0, 6795.0, 2923.0, 2403.0, 3403.0, 3915.0, 2405.0, 4390.0, 437.0, 1322.0, 486.0, 1923.0, 3189.0, 3969.0, 3423.0, 6022.0, 3935.0, 7667.0, 287.0, 955.0, 5831.0, 400.0, 2115.0, 4339.0, 1926.0, 4565.0, 7738.0, 1121.0, 570.0, 2658.0, 4324.0, 2943.0, 5284.0, 6314.0, 0.0, 1676.0, 7603.0, 1964.0, 2662.0, 5184.0], [1947.0, 6186.0, 2686.0, 7502.0, 4706.0, 1224.0, 482.0, 1987.0, 1486.0, 6507.0, 2137.0, 1564.0, 2860.0, 3138.0, 1289.0, 2928.0, 1948.0, 355.0, 1501.0, 1641.0, 3029.0, 2553.0, 2541.0, 5892.0, 3331.0, 7190.0, 1581.0, 743.0, 4994.0, 1277.0, 440.0, 4265.0, 1086.0, 3548.0, 7556.0, 600.0, 1380.0, 1002.0, 4046.0, 1659.0, 3997.0, 5837.0, 1676.0, 0.0, 7521.0, 744.0, 2325.0, 4670.0], [6835.0, 3472.0, 5661.0, 1877.0, 3241.0, 7805.0, 7635.0, 7391.0, 6934.0, 1268.0, 5459.0, 5983.0, 4697.0, 4647.0, 6338.0, 6419.0, 8005.0, 7508.0, 7989.0, 5957.0, 4527.0, 6290.0, 5213.0, 1629.0, 4312.0, 1798.0, 7844.0, 7644.0, 3704.0, 7567.0, 7537.0, 3296.0, 6436.0, 4830.0, 461.0, 7322.0, 7986.0, 7395.0, 3478.0, 6285.0, 5585.0, 2205.0, 7603.0, 7521.0, 0.0, 6805.0, 5208.0, 3102.0], [1542.0, 5461.0, 2023.0, 6758.0, 3962.0, 1670.0, 1054.0, 1785.0, 1112.0, 5773.0, 1394.0, 827.0, 2126.0, 2395.0, 555.0, 2428.0, 2334.0, 887.0, 1962.0, 1071.0, 2355.0, 2012.0, 1801.0, 5178.0, 2589.0, 6446.0, 1974.0, 1231.0, 4264.0, 1609.0, 763.0, 3576.0, 422.0, 2839.0, 6829.0, 902.0, 1866.0, 951.0, 3328.0, 1012.0, 3386.0, 5095.0, 1964.0, 744.0, 6805.0, 0.0, 1644.0, 3928.0], [2379.0, 4390.0, 1867.0, 5360.0, 2651.0, 2704.0, 2432.0, 2879.0, 2196.0, 4249.0, 711.0, 892.0, 756.0, 1351.0, 1297.0, 2749.0, 3098.0, 2302.0, 2939.0, 777.0, 711.0, 2336.0, 1077.0, 3581.0, 1284.0, 5041.0, 2838.0, 2465.0, 3209.0, 2501.0, 2404.0, 1941.0, 1244.0, 2140.0, 5267.0, 2128.0, 2904.0, 2429.0, 1755.0, 1563.0, 3125.0, 3680.0, 2662.0, 2325.0, 5208.0, 1644.0, 0.0, 2532.0], [3744.0, 2088.0, 2560.0, 2844.0, 304.0, 5230.0, 4884.0, 4296.0, 3876.0, 1914.0, 2534.0, 3109.0, 1836.0, 1592.0, 3406.0, 3337.0, 5618.0, 4736.0, 5469.0, 3302.0, 2042.0, 3189.0, 2190.0, 1639.0, 1340.0, 2528.0, 5369.0, 4957.0, 1196.0, 5032.0, 4603.0, 1381.0, 3619.0, 1751.0, 3013.0, 4608.0, 5432.0, 4380.0, 1000.0, 3254.0, 2664.0, 1169.0, 5184.0, 4670.0, 3102.0, 3928.0, 2532.0, 0.0]
         ]

p = getPopulation()

for i in range(SIZE):
    f[i] = getDistance(p[i])

# 10000세대까지 돌리고 종료
while generation <= 1000:
    isVisited = [False for i in range(SIZE)]

    # Crossover 3회
    for i in range(0, 3, 1):
        
        ### Selection
        # i1 = rouletteWheel()
        # i2 = rouletteWheel()
        c1,c2,c3,c4= random.sample(range(SIZE),4)
        i1,i2 = tournamentSelection(c1,c2), tournamentSelection(c3,c4)

        ### Crossover
        # offspring = cycleCrossover(p[i1], p[i2])
        offspring = edgeRecombinationCrossover(p[i1], p[i2])
        # offspring = pmx(p[i1], p[i2], 5, 10)
        # offspring = orderCrossover(p[i1], p[i2], 5, 12)
        
        ### Mutation
        mutate(offspring)
        # inversion_mutation(offspring, 0.05)
        
        ### Local Search
        # offspring = two_opt(offspring)
        # offspring = twohalf_opt(offspring)
        # offspring = three_opt(offspring)
        offspring = LK(offspring)
        
        worstIdx = getWorstIdx()
        p[worstIdx] = offspring
        f[worstIdx] = getDistance(p[worstIdx])
        
    generation += 1
# main 종료

# 최종 출력
print("최단 경로 : ", p[getBestIdx()])
print("최단 거리 : ", f[getBestIdx()])






